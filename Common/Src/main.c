/****************************************Copyright (c)****************************************************
**                               Guangzou FlyAudio Development Co.LTD.
**                                     
**                                 http://www.FlyAudio.com
**
**------------------------------------File Info---------------------------------------------------------
** File name: 			    main.c
** Last modified Date:     	2013.02.27
** Last Version: 		    1.0
** Descriptions: 	        The assembly functions that a uC/OS-II port requires
**                         
**-------------------------------------------------------------------------------------------------------
** Created By:       	    LDH
** Created date:   	   		2013.02.27
** Version:			    	1.0
** Descriptions: 		    
**
**-------------------------------------------------------------------------------------------------------
** Modified by:            
** Modified date:          2013.02.27
** Version:                1.0
** Description:            
**
*********************************************************************************************************/

#define 	_GLOBAL_INFO_GLOABL_
#include "config.h"
#include "includes.h"
#include "lpc17xx_lib.h"
#include "fs_include.h"
#include "UserType.h"



/*----------------------------------------------------------------------------------------------------------------------------------------------------------

多任务系统:	分为3层,最上面的是用户程序,中间的为OS,最下面的是跟硬件相关的操作lpc17xx;
			整个系统在每个层都定义一个一个头文件(分别为:UserType.h,includes.h,lpc17xx_lib.h)
			用来包含所属层的一些都文件,方便处理;  config.h为系统的配置文件

User:  		 main.c (UserType.h)  UserType.h包含:	
													
------------------------------------------------------------------------------------------------------------------------------------------------------------
硬件抽象层: interface.c	将硬件抽象出一层
------------------------------------------------------------------------------------------------------------------------------------------------------------
OS:			 OS_CORE.C (includes.h) includes.h包含:	os_cfg.h,os_cpu.h,ucos_ii.h	
------------------------------------------------------------------------------------------------------------------------------------------------------------
LPC17xx:	 (lpc17xx_gpio.h lpc17xx_lib.h)
------------------------------------------------------------------------------------------------------------------------------------------------------------


1. 关于中断优先级那点事...........
   1.1 	在设置中断优先级的时候我们去配置中断优先级寄存器NVIC->IP[240];但一个MCU不太可能有240个中断,首先我们如果
   		想知道这个MCU有多少个中断呢？我们可以去读一个寄存器SCnSCB->ICTR地址：0xE000E004	,我们实验得出bit[4:0] = 1;
   		ICTR:

	   	bit
	   	4:0  INTLINESUM  R  -  中断输入的数量，以 32为粒度，如
	   												0=1至32 
													1=33至 64 
													2=65至 96  

	1.2 在中断优先级中有个抢占优先级和子优先级的概念:
			概念:CM3还把 256级优先级按位分成高低两段，分别称为抢占优先级和子优先级,NVIC中有一个寄存器是“应用程序
		中断及复位控制寄存器”(AIRCR 地址：0xE000ED00)，它里面有一个位段名为“优先级组”(bit[10:8]),
		该位段的值对每一个优先级可配置的异常都有影响――把其优先级分为2个位段:MSB所在的位段(左边的)对应抢占优先级,
																	|
			Bit7	Bit6	Bit5	Bit4	Bit3	Bit2	Bit1	| Bit0
			  X		  X		  X		 X		 X		 X		  X		|  X
																	|
			分组位置  	表达抢占优先级的位段  	表达子优先级的位段	
				0			[7:1]  					[0:0] 
				1  			[7:2]  					[1:0] 
				2  			[7:3]  					[2:0] 
				3  			[7:4]  					[3:0] 
				4  			[7:5]  					[4:0] 
				5  			[7:6]  					[5:0] 
				6  			[7:7]  					[6:0] 
				7  			无  					[7:0](所有位)
		
			如果我们想知道芯片现在分组情况，我们可以去读SCB->AIRCR用寄存器的(bit[10:8])或者调NVIC_GetPriorityGrouping()函数,
		我们实验得出(bit[10:8] = 000即现在芯片的分组是第0组,但我们只用到前面的5位，那么我们现在使用的优先级都是抢占优先级;
			那我们可以修改分组情况么？答案是可以滴，但是优先级的分组都要预先经过计算论证,并且在开机初始化时一次性地设置好,
		以后就再也不动它了,只有在绝对需要且绝对有把握时,才小心地更改,并且要经过尽可能充分的测试,另外,优先级组所在的寄存器AIRCR
		也基本上是“一次成型”,只是需要手工产生复位时才写里面相应的位.



2.  关于HardFault_Handler问题的那些儿事.......
	2.1	每次调试程序的时候出现HardFault_Handler错误都是非常头疼的一件事,最近又碰上了,头疼....头疼.....;
		没办法,头疼也得解决,硬着头皮看《Cortex-M3权威指南》,写的真不错,关于CM3内核的资料,难得啊,经砖家研究发现,当出现HardFault_Handler错误时,
		首先,我们去look下硬fault状态寄存器,地址是0xE000ED2C ，我们在线仿真的时候可以看到这个地址中的内容:
			
			硬fault状态寄存器:		

			位段		名称			类型		复位值	  				描述
			bit31		DEBUGEVT		 R/W		   0			硬 fault因调试事件而产生
			bit30		FORCED			 R/W		   0			硬 fault是总线 fault，存储器管理 fault或是用法 fault上访的结果 
			bit29~2		  -				  -			   -					 -
			bit1		 VECTB			 R/W		   0			硬 fault是在取向量时发生的
			bit0			-			  -			   -					 -

			我们先主要关注下bit30,描述里面有个fault上访的东东.....是何方神圣.....,貌似是fault是总线 fault，存储器管理 fault或是用法 fault出现错误的结果...
			但是我们又不能确定到底是哪个fault造成的HardFault_Handler,哎......头又痛了.....！！！这时候我们又得看看其他fault的状态寄存器了...

			归纳下CM3中的 fault状态寄存器组: 

			0xE000_ED28  MMSR  MemManage fault状态寄存器 	1字节 
			0xE000_ED29  BFSR  总线 fault状态寄存器  		1字节
			0xE000_ED2A  UFSR  用法 fault状态寄存器  		2字节
			0xE000_ED2C  HFSR  硬 fault状态寄存器  			4字节
			0xE000_ED30  DFSR  调试 fault状态寄存器  		4字节  
			0xE000_ED3C  AFSR  辅助 fault状态寄存器  		4字节

			我们主要看看BFSR和MMSR:(pdf->P320)

			 MMSR:

			 位段		名称			类型		复位值	  				描述			可能的原因
			  7 	  MMARVALID  	      -  		  0  			=1时表示 MMAR有效 
			 6:5 		  -				  -			  -						 -
			  4		   MSTKERR 			 R/W		  0				 入栈时发生错误 		1.	堆栈指针的值被破坏，		2.	堆栈容易过大，已经超出 MPU允许的 region范围  
			  3		  MUNSTKERR			 R/W		  0				 出栈时发生错误			1.  异常服务例程破坏了堆栈指针;	2.  异常服务例程更改了 MPU配置 
			  2			  -	 			  -			  -					  -
			  1		  DACCVIOL			 R/W		  0				 数据访问违例			内存访问保护违例。这是MPU发挥作用的体现。常常是用户应用程序企图访问特权级 region所致 
			  0		  IACCVIOL			 R/W		  0				 取指访问违例

			  BFSR：

			  位段		名称			类型		复位值	  			描述				可能的原因
			  7 	  BFARVALID  	      -  		  0  			=1时表示 MMAR有效 
			 6:5 		  -				  -			  -						 -
			  4		   STKERR 			 R/W		  0				 入栈时发生错误 		自动入栈期间出错 : 1.  堆栈指针的值被破坏   2.  堆栈用量太大，到达了未定义存储器的区域 3.  PSP未经初始化就使用 
			  3		  UNSTKERR			 R/W		  0				 出栈时发生错误			自动出栈期间出错。如果没有发生过 STKERR，则最可能的就是在异常处理期间把 SP的值破坏了 
			  2		 IMPRECISERR 		 R/W		  0				 不精确的数据访问违例
			  1		  DACCVIOL			 R/W		  0				 精确的数据访问违例 
			  0		  IACCVIOL			 R/W		  0				 取指时的访问违例 


			 对于总线 fault 和存储器管理 fault,有时还能精确定位肇事指令的地址,当MMAVALID/BFARVALID 位被置位时即是精确 fault，存储器管理 fault的地址存储在 MMAR中
			 总线 fault的地址则存储在 BFAR中，在物理实现上，MMAR与 BFAR其实是同一个寄存器,因此同一时刻只能用一个――这是因为同一时刻只能出现一个fault.

			 CM3 中的 fault地址寄存器：

			 0xE000_ED34  MMAR  MemManage fault地址寄存器 		4字节
			 0xE000_ED38  BFAR  总线 fault地址寄存器  			4字节

			 说明:	如果 MMARVALID 或 BFARVALID 为 1则可以提供出事时的地址,	但要注意的是，当MARVALID/BFAVRALID 被清除后fault 地址寄存器中的值可能被擦除,
			 因此，必须先读BFAR/MMAR，再读 BFARVALID/MMARVALID.如果后者为零，则丢弃读出的地址值。通俗的讲如果 MMARVALID 或 BFARVALID 为 1,MMAR/BFAR保存着
			 当时出事时的地址;注意前提是MMARVALID 或 BFARVALID 为 1;

			 
			2.2 上报 fault状态寄存器
			 Fault服务例程最基本的工作就是上报 fault状态寄存器的值;
			 定位入栈PC的流程:
			 	   		
			 					  	   LR[bit2] = 0 / 1	 ?
									   			|
			 									|
												|
										 _______|_______
										|				|
										| = 0		1 =	|
										|				|
									  使用MSP		 使用PSP
										|				|
										|				|
										|				|
										 ――――――    ――――――
										    从SP-0X24出
											读取入栈PC值
											 定位PC

			总结:当出现HardFault_Handler时:
				
				 1.查看HFSR  硬 fault状态寄存器,看bit30是否为1,如果是1,则看第二步,如果不是,等死吧.......；
				 2.查看MMSR和BFSR的MMARVALID 或 BFARVALID 位是否为1,如果是1,则可以直接读取MMAR/BFAR中的值,确定发生异常时的地址;如果为0,则看第3步;
				 3.查看MMSR和BFSR寄存器的其它位看是否为1,例如 BFSR的STKERR为1,即自动入栈是出现错误,这时候我们就要查看当前使用的是MSP还是PSP,检查
				   代码是否在进入中断服务函数前有没有将MSP还是PSP指向一个合法的地址(内存)空间,可以根据手册上说的可能原因配合自己的代码找问题...！！
				 4.也可以通过2.2点说的方法找出异常时PC指针的值,但这种方法不一定每次都行的特别是你的MSP/PSP指向一个错误空间时就无法确定了....
----------------------------------------------------------------------------------------------------------------------------------------------------------*/
















/***********************************************************************
**函数名称:	  main
**函数功能:
**入口参数:
**返回参数:
***********************************************************************/
int main(void)
{
	IntDisAll();
	chipInit();
	OSInit();
	FS_Init();
	TaskInit();
   	OSStart();
	return 0;
}





